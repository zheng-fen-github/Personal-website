{"pageProps":{"book":[{"BookMessage":[{"pageTitle":"基础知识","pageContent":[{"pieceTitle":"对象","pieceMessage":["对象是具有一些特殊特性的关联数组。","它们存储属性（键值对），其中：\n\n属性的键必须是字符串或者 symbol（通常是字符串）。\n值可以是任何类型。","我们可以用下面的方法访问属性：\n\n点符号: obj.property。\n方括号 obj[\"property\"]，方括号允许从变量中获取键，例如 obj[varWithKey]"]},{"pieceTitle":"其他操作","pieceMessage":["删除属性：delete obj.prop。\n检查是否存在给定键的属性：\"key\" in obj。\n遍历对象：for(let key in obj) 循环。","对象是通过引用被赋值或复制的。换句话说，变量存储的不是“对象的值”，而是值的“引用”（内存地址）。所以复制这样的变量或者将其作为函数参数进行传递时，复制的是引用，而不是对象。基于复制的引用（例如添加/删除属性）执行的所有的操作，都是在同一个对象上执行的。\n\n我们可以使用 Object.assign 或者 _.cloneDeep(obj) 进行“真正的复制”（一个克隆）。"]}],"createTime":1586088946832},{"pageTitle":"垃圾回收","pageContent":[{"pieceTitle":"基本","pieceMessage":["垃圾回收是自动完成的，我们不能强制执行或是阻止执行。","当对象是可达状态时，它一定是存在于内存中的。","被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。"]}],"createTime":1586089179610},{"pageTitle":"Symbol","pageContent":[{"pieceTitle":"基础","pieceMessage":["Symbol 是唯一标识符的基本类型","Symbol 是使用带有可选描述（name）的 Symbol() 调用创建的。","Symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 Symbol 相等，那么我们应该使用全局注册表：Symbol.for(key) 返回（如果需要的话则创建）一个以 key 作为名字的全局 Symbol。使用 Symbol.for 多次调用 key 相同的 Symbol 时，返回的就是同一个 Symbol。"]},{"pieceTitle":"主要用景","pieceMessage":["“隐藏” 对象属性。 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 for..in 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。"]}],"createTime":1586089286234},{"pageTitle":"this","pageContent":[{"pieceTitle":"this","pieceMessage":["存储在对象属性中的函数被称为“方法.","方法允许对象进行像 object.doSomething() 这样的“操作”。","方法可以将对象引用为 this。"]},{"pieceTitle":"机制","pieceMessage":["this 的值是在程序运行时得到的。","一个函数在声明时，可能就使用了 this，但是这个 this 只有在函数被调用时才会有值。","以“方法”的语法调用函数时：object.method()，调用过程中的 this 值是 object。"]}],"createTime":1586089663750},{"pageTitle":"对象-原始值转换","pageContent":[{"pieceTitle":"基础","pieceMessage":["对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。","这里有三种类型（hint）：\n\n\"string\"（对于 alert 和其他需要字符串的操作）\n\"number\"（对于数学运算）\n\"default\"（少数运算符）","规范明确描述了哪个运算符使用哪个 hint。很少有运算符“不知道期望什么”并使用 \"default\" hint。通常对于内建对象，\"default\" hint 的处理方式与 \"number\" 相同，因此在实践中，最后两个 hint 常常合并在一起。"]},{"pieceTitle":"转换算法","pieceMessage":["调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，","否则，如果 hint 是 \"string\"\n尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。","否则，如果 hint 是 \"number\" 或者 \"default\"\n尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。"]}],"createTime":1586090105282},{"pageTitle":"构造器和操作符 \"new\"","pageContent":[{"pieceTitle":"基本","pieceMessage":["构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。","构造函数只能使用 new 来调用。这样的调用意味着在开始时创建了空的 this，并在最后返回填充了值的 this。"]}],"createTime":1586090362320}],"_id":"5e89cb1000d8364dc8cf97d0","BookTitle":"oeject","__v":0},{"BookMessage":[{"pageTitle":"原始类型的方法","pageContent":[{"pieceTitle":"基本","pieceMessage":["除 null 和 undefined 以外的原始类型都提供了许多有用的方法。我们将在即将到来的章节中研究这些内容。","从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整，以在内部对其进行优化，因此调用它们并不需要太高的成本。"]}],"createTime":1586090415051},{"pageTitle":"数字类型","pageContent":[{"pieceTitle":"写非常大的数字","pieceMessage":["附加 \"e\" 来省略 0，e 后面的数字就是零的个数。就像：123e6 是 123 后面接 6 个零。","\"e\" 后面的负数将导致数字除以 1 后面接着给定数量的零。e-6 那是一百万分之一。"]},{"pieceTitle":"对于不同的进制","pieceMessage":["可以在十六进制（0x），八进制（0o）和二进制（0b）系统中直接写入数字。","parseInt(str，base) 解析来自任何数字系统的整数，其基数为：2≤base≤36","num.toString(base) 将数字转换为数字系统中具有给定 base 的字符串。"]},{"pieceTitle":"将 12pt 和 100px 等值转换为数字","pieceMessage":["使用 parseInt / parseFloat 进行 软 转换，它从字符串中读取一个数字，然后返回错误发生前可以读取的值。"]},{"pieceTitle":"分数","pieceMessage":["使用 Math.floor，Math.ceil，Math.trunc，Math.round 或 num.toFixed(precision) 截取。","请记住，使用分数时会损失精度。"]}],"createTime":1586090558991}],"_id":"5e89d18d00d8364dc8cf97d2","BookTitle":"数据类型","__v":0}]},"__N_SSG":true}